---
layout: doc
date: 2023-12-03
---


# 执行上下文，执行栈，作用域，作用域链

## 名词解释：

- **执行栈（Execution Stack）**
- **执行上下文（Execution Context，EC）**
- **作用域（Scope）**
- **作用域链（Scope Chain）**
- **全局对象（Global Object，GO）**
- **活动对象（Activation Object，AO）**
- **变量对象（Variable Object）**
- **可执行代码（Executable Code）**：
- **词法环境（Lexical Environment）**：
- **外部词法环境（Outer Lexical Environment）**：
- **闭包信息（Closure Information）**：

## 执行上下文

简而言之，执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。

当执行一个函数或者一个代码块时，都会创建一个新的执行上下文。

## 执行上下文的类型

JavaScript 中有三种执行上下文类型。

1. **全局执行上下文**：

   全局执行上下文是代码在最顶层执行的上下文，它在整个程序的生命周期中存在。一个程序中只会有一个全局执行上下文。

   在浏览器中，全局执行上下文通常与全局对象 **`winndow`** 相关联，包含全局变量和全局函数

   在 Node 环境中，全局执行上下文与 `**global`\*\* 对象相关联

2. **函数执行上下文：**

   每当一个函数被调用时, 都会为该函数创建一个新的上下文。

   每个函数都有它自己的执行上下文，不过是在函数被**调用时创建的**。

3. **Eval 函数执行上下文（基本不用）**

## 执行上下文的组成

- **变量对象（Variable Object）**：
- **作用域链（Scope Chain）**：
- **this 值**：

---

## 执行栈

<aside>
💡 **LIFO ：Last In First Out（后进先出）**

</aside>

执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 **LIFO** （后进先出）数据结构的栈，被用来存储代码运行时创建的**所有执行上下文**。

当 JavaScript 引擎**第一次**遇到你的脚本时，它会**创建一个全局的执行上下文**并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。

根据执行栈 **LIFO** 规则，当栈顶函数运行完成后，其对应的 **函数执行上下文** 将会从执行栈中弹出，上下文控制权将移到当前执行栈的 **下一个执行上下文**

**执行栈的工作原理如下：**

![2019-07-24-060219.webp](%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%8C%E6%89%A7%E8%A1%8C%E6%A0%88%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%20189c310e920243e4be9bbf55e6ba7bfd/2019-07-24-060219.webp)

## **执行上下文的创建和执行过程**

<aside>
💡 在执行上下文的创建阶段，会依次进行**参数的确定，函数声明的提升，变量声明的提升**。参数会接收传入的实参，并与参数名称对应。**函数声明会覆盖同名的函数声明**，**变量声明同名则会被忽略**。

</aside>

**创建阶段**

- **确定 this 绑定**
- **创建词法环境**
- **创建变量环境**
- **提升函数声明，同名声明 覆盖**
- **确定参数，接收实参，确定 arguments 属性，和参数对应**
- **提升变量声明，同名声明 忽略**

**执行阶段**

- **在执行阶段，代码会按照顺序执行，并且根据作用域链来查找变量和函数。**

---

## 作用域

<aside>
💡 **作用域就是一个独立的区域，它可以让变量不会向外暴露出去。作用域最大的用处就是隔离变量。内层作用域可以访问外层作用域。一个作用域下可能包含若干个执行上下文。**

</aside>

首先，JavaScript属于**解释型语言**，JavaScript的执行分为解释和执行两个阶段，这两个阶段所做的事并不一样：

**解释阶段：**

- 词法分析
- 语法分析
- 作用域规则确定

**执行阶段：**

- 创建执行上下文
- 执行函数代码
- 垃圾回收

JS 有三种作用域：

- 全局作用域：整个程序运行之后产生的，有且只有一个，一般 this 都指向全局作用域
- 函数作用域：也叫局部作用域，函数内部运行产生
- 块级作用域：ES6 新增，在尖括号内部使用 let const 会形成块级作用域隔离变量

在执行阶段，代码会按照顺序执行，并且根据作用域链来查找变量和函数。每个函数都有自己的执行上下文集合，形成了作用域链的链式结构。

JavaScript解释阶段便会确定作用域规则，因此**作用域在函数定义时就已经确定了**，而不是在函数调用时确定，但是**执行上下文是函数执行之前创建的**。执行上下文最明显的就是this的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。

执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。

## 作用域链

每个函数都有一个特殊的属性 **[[Scopes]]** 是 JavaScript 引擎内部用来表示作用域链（Scope Chain）的一个属性，它不是 JavaScript 语言规范中公开的标准属性，而是引擎的内部实现细节之一。

引子：

当一个函数运行时会生成对应的函数执行上下文，而每个执行上下文都有一个属性，**[[scopes]]**，它保存了**对父级执行上下文的引用**，它是一个伪数组结构，

定义：

在函数内部访问一个变量或函数的时候，会现在自身的词法环境中查找，如果找不到，则继续沿着作用域

作用域链的创建是在函数定义时确定的，而不是在函数执行时。这意味着无论函数在何处被调用，它的作用域链都是固定的。

因此，当我们在函数内部创建一个新的函数时，内部函数也会继承外部函数的作用域链，形成闭包，可以访问外部函数的变量。

作用域链的概念非常重要。当在函数中引用一个变量时，JavaScript 引擎会先在当前函数的执行上下文中查找该变量，如果找不到，就会继续在外部词法环境中查找，直到找到或者到达全局执行上下文。这种嵌套的作用域链机制使得我们可以在不同的函数中访问和共享变量。

每一个函数它自己都有一个执行上下文的集合（链式结构）叫作用域链

```jsx
function say() {
  function a() {
    function b() {
      function c() {}
    }
  }
}
```

## 执行上下文，执行栈

## 作用域和作用域链

作用域限制了程序变量的

变量查找规则是首先在当前执行环境的 **AO** 中寻找，没找到，则顺着执行环境中属性中的作用域链 [[scopes]] 指向的 中寻找，一直到 GO 下的 AO

## 闭包

引子：

我们都知道，一个函数有它自己的作用域，也就是函数内部声明的变量和函数可以访问到的区域，这样可以隔离变量，函数外部无法使用其内部的变量和函数，不会产生变量重名和数据污染

作用域在函数定义时就会产生，而执行上下文在函数执行时才会产生

理论上来说，只要是一个函数嵌套就会产生闭包！

```jsx
function A() {
  function B() {}
}
```

闭包的定义：

**闭包就是一个函数引用另一个函数内部的变量，因为变量被引用着，所以当另外一个函数执行结束，其相应的执行上下文弹出栈时， 变量并不会被回收。所以可以继续使用它内部定义的变量**

根据之前掌握的执行上下文知识我们知道，当函数创建时，其内部就会保存它定义时所在的作用域

当这个函数执行时，其内部会生成对应的执行上下文并压入执行上下文栈中，当这个函数运行导致另一个函数被定义的时候，另一个函数会保存上一级函数的作用域，当这个函数被返回且被外部变量接收的时候，运行这个函数

闭包是指一个函数运行时生成的执行上下文，其中包含这个函数声明的变量和函数。如果在函数内部定义了嵌套函数，那么这个嵌套函数会保存对上一级函数执行上下文的引用。当将这个嵌套函数返回并在外部接收时，外部函数执行完成后，它的执行上下文会被回收。然而，由于嵌套函数引用了外部函数的执行上下文，垃圾回收机制无法对其进行回收。因此，嵌套函数可以持续访问外部函数执行上下文中的变量和函数。

总结：

闭包是指一个函数嵌套结构，内部函数可以引用外部函数中定义的变量或函数。当外部函数执行完成后，内部函数仍然可以引用外部函数的执行上下文，因此不会被垃圾回收，从而使内部函数可以继续使用外部函数的执行上下文。
